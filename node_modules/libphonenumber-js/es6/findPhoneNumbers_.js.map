{"version":3,"sources":["../source/findPhoneNumbers_.js"],"names":["PLUS_CHARS","VALID_PUNCTUATION","VALID_DIGITS","WHITESPACE","parse","VALID_PHONE_NUMBER_WITH_EXTENSION","createExtensionPattern","parsePreCandidate","isValidPreCandidate","isValidCandidate","EXTN_PATTERNS_FOR_PARSING","WHITESPACE_IN_THE_BEGINNING_PATTERN","RegExp","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","findPhoneNumbers","text","options","metadata","undefined","search","PhoneNumberSearch","phones","hasNext","push","next","searchPhoneNumbers","Symbol","iterator","done","value","regexp","matches","exec","number","startsAt","index","replace","length","result","parseCandidate","find","extended","phone","endsAt","state","last_match","Error"],"mappings":"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","sourcesContent":["// This is a legacy function.\r\n// Use `findNumbers()` instead.\r\n\r\nimport {\r\n\tPLUS_CHARS,\r\n\tVALID_PUNCTUATION,\r\n\tVALID_DIGITS,\r\n\tWHITESPACE\r\n} from './constants'\r\n\r\nimport parse from './parse_'\r\nimport { VALID_PHONE_NUMBER_WITH_EXTENSION } from './helpers/isViablePhoneNumber'\r\nimport createExtensionPattern from './helpers/extension/createExtensionPattern'\r\n\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\r\nimport isValidCandidate from './findNumbers/isValidCandidate'\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nexport const EXTN_PATTERNS_FOR_PARSING = createExtensionPattern('parsing')\r\n\r\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\r\nconst PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$')\r\n\r\n// // Regular expression for getting opening brackets for a valid number\r\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\r\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\r\n\r\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\r\n\r\nexport default function findPhoneNumbers(text, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\tconst phones = []\r\n\twhile (search.hasNext()) {\r\n\t\tphones.push(search.next())\r\n\t}\r\n\treturn phones\r\n}\r\n\r\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\r\nexport function searchPhoneNumbers(text, options, metadata) {\r\n\t/* istanbul ignore if */\r\n\tif (options === undefined) {\r\n\t\toptions = {}\r\n\t}\r\n\tconst search = new PhoneNumberSearch(text, options, metadata)\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (search.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: search.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\r\nexport class PhoneNumberSearch {\r\n\t// Iteration tristate.\r\n\tstate = 'NOT_READY'\r\n\r\n\tconstructor(text, options, metadata) {\r\n\t\tthis.text = text\r\n\t\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t\t// code coverage would decrease for some weird reason.\r\n\t\tthis.options = options || {}\r\n\t\tthis.metadata = metadata\r\n\r\n\t\tthis.regexp = new RegExp(VALID_PHONE_NUMBER_WITH_EXTENSION, 'ig')\r\n\t}\r\n\r\n\tfind() {\r\n\t\tconst matches = this.regexp.exec(this.text)\r\n\t\tif (!matches) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet number = matches[0]\r\n\t\tlet startsAt = matches.index\r\n\r\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\r\n\t\tstartsAt += matches[0].length - number.length\r\n\t\t// Fixes not parsing numbers with whitespace in the end.\r\n\t\t// Also fixes not parsing numbers with opening parentheses in the end.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/252\r\n\t\tnumber = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '')\r\n\r\n\t\tnumber = parsePreCandidate(number)\r\n\r\n\t\tconst result = this.parseCandidate(number, startsAt)\r\n\t\tif (result) {\r\n\t\t\treturn result\r\n\t\t}\r\n\r\n\t\t// Tail recursion.\r\n\t\t// Try the next one if this one is not a valid phone number.\r\n\t\treturn this.find()\r\n\t}\r\n\r\n\tparseCandidate(number, startsAt) {\r\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Don't parse phone numbers which are non-phone numbers\r\n\t\t// due to being part of something else (e.g. a UUID).\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\r\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\r\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID')) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// // Prepend any opening brackets left behind by the\r\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\r\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\r\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\r\n\t\t// if (full_number_starts_at >= 0)\r\n\t\t// {\r\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\r\n\t\t// \tstartsAt = full_number_starts_at\r\n\t\t// }\r\n\t\t//\r\n\t\t// this.searching_from = matches.lastIndex\r\n\r\n\t\tconst result = parse(number, this.options, this.metadata)\r\n\t\tif (!result.phone) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tresult.startsAt = startsAt\r\n\t\tresult.endsAt = startsAt + number.length\r\n\t\treturn result\r\n\t}\r\n\r\n\thasNext() {\r\n\t\tif (this.state === 'NOT_READY') {\r\n\t\t\tthis.last_match = this.find()\r\n\t\t\tif (this.last_match) {\r\n\t\t\t\tthis.state = 'READY'\r\n\t\t\t} else {\r\n\t\t\t\tthis.state = 'DONE'\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.state === 'READY'\r\n\t}\r\n\r\n\tnext() {\r\n\t\t// Check the state and find the next match as a side-effect if necessary.\r\n\t\tif (!this.hasNext()) {\r\n\t\t\tthrow new Error('No next element')\r\n\t\t}\r\n\t\t// Don't retain that memory any longer than necessary.\r\n\t\tconst result = this.last_match\r\n\t\tthis.last_match = null\r\n\t\tthis.state = 'NOT_READY'\r\n\t\treturn result\r\n\t}\r\n}"],"file":"findPhoneNumbers_.js"}