{"version":3,"sources":["../source/parse_.js"],"names":["VALID_DIGITS","PLUS_CHARS","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","ParseError","Metadata","isViablePhoneNumber","extractExtension","parseIncompletePhoneNumber","getCountryCallingCode","isPossibleNumber","parseRFC3966","PhoneNumber","matchesEntirely","extractCountryCallingCode","extractCountryCallingCodeFromInternationalNumberWithoutPlusSign","extractNationalNumber","stripIddPrefix","getCountryByCallingCode","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","AFTER_PHONE_NUMBER_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","parse","text","options","metadata","defaultCountry","hasCountry","v2","Error","parseInput","extract","formattedPhoneNumber","number","ext","parsePhoneNumber","defaultCallingCode","country","nationalNumber","countryCallingCode","carrierCode","hasSelectedNumberingPlan","length","phoneNumber","valid","extended","nationalNumberPattern","result","possible","possibleLengths","phone","extractFormattedPhoneNumber","throwOnError","startsAt","search","slice","replace","indexOf","withExtensionStripped","selectNumberingPlan","isNonGeographicCallingCode","exactCountry"],"mappings":"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","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN\r\n} from './constants'\r\n\r\nimport ParseError from './ParseError'\r\nimport Metadata from './metadata'\r\nimport isViablePhoneNumber from './helpers/isViablePhoneNumber'\r\nimport extractExtension from './helpers/extension/extractExtension'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\nimport { isPossibleNumber } from './isPossibleNumber_'\r\nimport { parseRFC3966 } from './helpers/RFC3966'\r\nimport PhoneNumber from './PhoneNumber'\r\nimport matchesEntirely from './helpers/matchesEntirely'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode'\r\nimport extractCountryCallingCodeFromInternationalNumberWithoutPlusSign from './helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign'\r\nimport extractNationalNumber from './helpers/extractNationalNumber'\r\nimport stripIddPrefix from './helpers/stripIddPrefix'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\r\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// Examples:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext } = parseInput(text, options.v2, options.extract)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ?\r\n\t\tmatchesEntirely(nationalNumber, metadata.nationalNumberPattern()) :\r\n\t\tfalse\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\t// isInternational: countryCallingCode !== undefined\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (\r\n\t\t\toptions.extended === true &&\r\n\t\t\tmetadata.possibleLengths() &&\r\n\t\t\tisPossibleNumber(nationalNumber, metadata) ? true : false\r\n\t\t),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (throwOnError) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tif (extract === false) {\r\n\t\treturn text\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2, extract) {\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0) {\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\tlet number = extractFormattedPhoneNumber(text, extract, v2)\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !isViablePhoneNumber(number)) {\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst withExtensionStripped = extractExtension(number)\r\n\tif (withExtensionStripped.ext) {\r\n\t\treturn withExtensionStripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, nationalNumber, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone: nationalNumber\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\t// Extract calling code from phone number.\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tparseIncompletePhoneNumber(formattedPhoneNumber),\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\t// Choose a country by `countryCallingCode`.\r\n\tlet country\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t}\r\n\t// If `formattedPhoneNumber` is in \"national\" format\r\n\t// then `number` is defined and `countryCallingCode` isn't.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tif (defaultCountry) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t} else {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tcountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumber(\r\n\t\tparseIncompletePhoneNumber(number),\r\n\t\tmetadata\r\n\t)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = getCountryByCallingCode(countryCallingCode, nationalNumber, metadata)\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\t/* istanbul ignore if */\r\n\t\tif (exactCountry === '001') {\r\n\t\t\t// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\r\n\t\t\t// If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\r\n\t\t\t// then remove the \"istanbul ignore if\".\r\n\t\t} else {\r\n\t\t\tmetadata.country(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}"],"file":"parse_.js"}