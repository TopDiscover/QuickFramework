# 关于QuickFramework
- **Q : 为什么使用单场景？**
    - **保证视图在切换场景时正常弹出**
    * 如下情况，如多场景情况下，A场景->B场景，A场景上请求网络数据希望在B场景上弹出，当收到网络返回时
    还需要检查当前是否在B场景中，如果不在则压入呆显示队列中，等进入B场景，检查当前是否有显示视图队列
    如果有显示的视图，依次弹出，但如果采用单场景化，无须关心在哪一个场景，收到网络回复直接弹出。
    - **保护界面状态**
    * 还是在多场景下，在切换场景时，必定会先把场景上所有视图关闭，清除数据，但若有需要在A场景下显示的
    界面也希望在B场景下显示，此时场景的过渡，会先关闭界面，进入B场景时显示，但如果场景上有ListView类
    似的控制，也希望在切换场景时，显示之前玩家操作显示的位置，那么必定会花费额外的工作去保存玩家在A场景
    上操作界面的相关信息，再进入B场景时，恢复玩家对界面操作的所有状态，但如果只是单场景，可以模拟一个
    场景的切换动作，直接隐藏掉界面，进入B场景，直接显示，无须保存界面的状态。

- **Q : 项目为什么不推荐使用在预置体中直接挂载脚本？**
    - **方便重构**
    * 如下情况，当你发现目录结构不合理，或者文件名取名有误时，但此时已经在预置上挂载了过多的组件，还有
    些项目的子游戏是在不同的svn版本管理下，在开发时，并不会放入全量的代码进入开发，如果如果此时改名或
    移动目录，可能会造成文件的uuid发生变化，Creator上只会显示该脚本为Misson状态，并不会显示之前挂载
    的是哪一个脚本，若项目足够大，一个脚本的uuid变化，可能会造成大量预置体，重新设置挂载脚本，提高了
    维护的成本
- **Q : 为什么项目都采用预置体+UIView组件绑定方式？**
    - 1，统一化管理，工厂式创建，方便实现统一的动画效果，一个公司的界面显示动画，可能大多数情况下是统一风格，如果我们要实现统一定制化
    动画，只需要在UIView中统一处理，直接显示通过UIManager.open()方式调用
    * 2，把内存及资源的管理交到管理器处理，减少开发都对何时释放资源，何时加载资源的烦恼，只关注自己的
    业务逻辑处理，无须关注资源的加载与释放
    * 3，接口统一，方便后期对界面的打开次数统计，以提供数据给运营人员，查看该模块的受欢迎程度
- **Q : 项目主要核心模块为什么都在管理器Manager上？**
    - 提高可读性，新手上手快，拿到代码只能从Manager上直接了解整个项目的结构模块，尽量避免全局变量满天飞的情况
    后面框架的使用者也可直接把全局的通过数据直接挂载到Manager中使用，减少全局变量的污染。
- **Q : 项目为什么推荐万事尽量保留类型？***
    - 个人观点，项目采用VSCode + Creator + typescript 方式进行开发，而typescript VSCode 都是Microsoft 公司
    的产品，Microsoft公司在JavaScript 基础上加上了type,就是为了解决弱语言类型无类型化，可读性差，
    * 1，您可以清楚你的实际来自哪一个类型，跟继承的关系
    * 2，编辑友好加上VSCode的智能代码提示跟静态语法检查，让你在开发时，减少错误
    * 3，代码更严谨，可在传入参数中限制传入的类型，类型的检查交给VSCode处理
    * 4，方便重构，如果当你发现某个文件旋转位置不对，可直接在VSCode中拖动到你想要的位置，VSCode会自动的更正你托动
    代码所有引用的位置，或者对API 类名等修改操作，VSCode也会自动更改所有引用此类型的地方，降低重构的成本
    * 5，最后说一句，没有人比VSCode 更懂TypeScript ,TypeScript的重点在Type,无论什么情况，尽量保留类型。
# 框架定位
本框架主要为轻量级游戏打造的一个基础框架雏形，可适用于休闲类，小游戏类，棋牌类，文字游戏类等轻或中度型游戏的开发，
功能还在完善中，后面优化及功能的扩展继续进行中
# 如何使用框架
## 1，修正你的Creator引擎
本框架提供了相应的插件，对引擎有部分源码的修改，再下载完本项目，用Creator打后开需要先执行引擎修正，以确保对引擎修改的部分同步到您的Creator安装目录

![引擎修正](https://images.gitee.com/uploads/images/2021/0904/223205_803c6978_393413.png "屏幕截图.png")
## 2，创建目录结构
可参考如下结构

![结构说明](https://images.gitee.com/uploads/images/2021/0904/224514_d546e3cc_393413.png "屏幕截图.png")

- animation 为动画资源
- audio 声音资源
- font 字体资源
- image 为散图不会打包成大图集资源
- prefabs 为预置体存放位置
- script 为bundle的代码存放位置
- texture 为打包自动图集资源

**可根据自己项目及个人习惯而定**

## 3，设置Bundle

如下图

![设置Bundle](https://images.gitee.com/uploads/images/2021/0904/225100_40e33148_393413.png "屏幕截图.png")

## 4，编写bundle逻辑入口
- **1,入口继承LogicImpl**
- **2,指定逻辑类型**
- **3,监听逻辑事件（这个后面会有优化）**
- **4,返回bundle名**
- **5,处理逻辑事件，打开对应视图GameOneView**
- **6,逻辑入口交给逻辑管理器**
```ts
import { Logic } from "../../../scripts/framework/core/logic/Logic";
import { LogicImpl } from "../../../scripts/framework/core/logic/LogicImpl";
import GameOneView from "./view/GameOneView";

class GameOneLogic extends LogicImpl {

    /**@description 指定逻辑类型 */
    logicType: Logic.Type = Logic.Type.GAME;

    /**@description 添加逻辑处理事件监听 */
    protected addEvents() {
        super.addEvents();
        this.addUIEvent(Logic.Event.ENTER_GAME, this.onEnterGame);
    }

    /**@description 返回你的bundle名，即在creator中设置的bundle名 */
    protected get bundle() {
        return "gameOne";
    }

    /**@description 处理进入该模块的游戏事件 */
    private onEnterGame(data) {
        if (data == this.bundle) {
            Manager.uiManager.open({ type: GameOneView, bundle: this.bundle });
        }
    }
}
/**@description 将自己的Bundle逻辑入口交给逻辑管理器 */
Manager.logicManager.push(GameOneLogic);
```
## 5，创建GameOneView预置

![GameOneView预置](https://images.gitee.com/uploads/images/2021/0904/230320_7e3d65df_393413.png "屏幕截图.png")

## 6，创建GameOneView视图脚本
- **1，继承UIView实现视图**
- **2，绑定脚本与预置体关系**
- **3，进入完成，通知逻辑管理器进入bundle完成**
- **4，退出当前bundle，进入大厅，派发逻辑事件进入大厅**
代码如下：
```ts
import SettingView from "../../../../scripts/common/component/SettingView";
import { ViewZOrder } from "../../../../scripts/common/config/Config";
import { dispatchEnterComplete, Logic } from "../../../../scripts/framework/core/logic/Logic";
import UIView from "../../../../scripts/framework/core/ui/UIView";
import { Macro } from "../../../../scripts/framework/defines/Macros";

const {ccclass, property} = cc._decorator;

@ccclass
export default class GameOneView extends UIView {

    /**@description 绑定脚本与预置关系 */
    public static getPrefabUrl(){
        return "prefabs/GameOneView";
    }

    private testNode : cc.Node = null;

    onLoad(){
        super.onLoad();
        let goback = cc.find("goBack",this.node);
        goback.on(cc.Node.EventType.TOUCH_END,()=>{
            // 派发逻辑处理事件，返回到大厅
            dispatch(Logic.Event.ENTER_HALL);
        });
        goback.zIndex = 10;

        this.audioHelper.playMusic("audio/background",this.bundle);

        cc.find("setting",this.node).on(cc.Node.EventType.TOUCH_END,this.onSetting,this);
        // 进入完成，通知逻辑管理器bundle进入完成
        dispatchEnterComplete({type:Logic.Type.GAME,views:[this]});
    }

    private onSetting(){
        Manager.uiManager.open({
            type:SettingView,
            bundle:Macro.BUNDLE_RESOURCES,
            zIndex:ViewZOrder.UI,
            name:"设置界面"
        })
    }
}
```
