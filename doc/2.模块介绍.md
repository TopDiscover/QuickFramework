# 公共组件
## 1，声音组件AudioComponent
集成了对声音的播放，停止，音量大小调整等功能
该声音组件会在UIView的onLoad中初始化，每一个UIView都具有播放声音的组件
- 背景音乐,如果是在onLoad中播放，必须先调用基类的onLoad后再使用this.audioHelper，
目前只支持一个背景音乐的播放，当playMusic下一个音乐时，会自动停止掉之前的背景音乐，播放当前背景音乐
如某些资源希望播放后，一直驻留在内存中，可使用Manager.globalAudio来对声音进行操作，该声音全局组件
播放的资源，都会默认为全局常驻资源，生命周期跟App的生命周期一致
```ts
//播放背景音乐，
this.audioHelper.playMusic("audio/background",this.bundle);
//停止背景音乐
this.audioHelper.stopMusic()
//播放全局背景音乐，前提，该背景音效文件在主包内，否则可能会出现退出bundle删除bundle资源，造成第二次无法正常播放
//可直接使用全局声音组件，这种情况下播放的音乐，将会一直驻留在内存中，直接游戏退出才会释放
Manager.globalAudio.playMusic("audio/background",this.bundle);
//使用全局播放，使用全局的停止
Manager.globalAudio.stopMusic()
```
- 音效，音效的返回是一个异步处理的过程，如果没有加载音效情况下，调用播放接口会先加载完成才会播放，在Promise回调中返回音效id
```ts
//播放音效
this.audioHelper.playEffect("audiourl",this.bundle,false).then((id)=>{
    this.audioID = id;
});
//停止音效
this.audioHelper.stopEffect(this.audioID);
//如弹出框的公共声音，可直接使用全局的声音组件操作Manager.globalAudio
```
- 音量
音量的设置是对全局进行设置，全局的声音组件及UIView的声音组件都能操作当前游戏的音量设置
```ts
//音效音量
this.audioHelper.effectVolume = value; //value(0.0~1.0)
//背景音乐音量
this.audioHelper.musicVolume = value; //value(0.0~1.0)
```
- 声音开关
声音开关的设置，同音量一样，全局的声音组件及UIView的声音组件都能操作当前游戏的音量开关设置
```ts
//音效开关
this.audioHelper.isEffectOn = true;
//背景音效开关
this.audioHelper.isMusicOn = true;
```
- 声音用户数据保存,全局的声音组件及UIView的声音组件都能操作当前游戏的用户数据保存
```ts
this.audioHelper.save()
```
## 2，网络控制器Controller
个人建议，该模块只用于对网络数据的接收逻辑业务的处理，如果当你收到某个网络消息后，处理完相关数据流程在通知视图更新显示，
- service注入，该组件接收来自哪一条网络的
- 网络事件注册绑定
- 网络控制器注册到网络管理器中
示例如下:
```ts
//网络注入
@setService(ChatService.instance)
export default class TestChatNetController extends Controller<ChatService> {
    //绑定网络事件
    protected addEvents() {
        super.addEvents()
        this.addNetEvent(GetCmdKey(MainCmd.CMD_LOBBY, SUB_CMD_LOBBY.TEST_JSON_MSG), this.onTestJsonMessage, TestJsonMessage, true);
    }
    //网络事件处理
    private onTestJsonMessage(data: TestJsonMessage) {
        //对网络数据进入处理之后，得到界面需要结果
        if ( Manager.gameView) Manager.gameView.updateView(data);
        //如需要其它地方收到此消息的数据，可派发广播，如果玩家金钱变更等，根据自己的业务逻辑而定
        dispatch(CommonEvent.TEST_JSON_MSG, data.hello);
    }
}

Manager.hallNetManager.register(TestChatNetController);
```
## 3，事件组件EventComponent
该组件主要用于对网络及UI事件的绑定，只要是EventComponent的子类，都有接收全局广播事件的能力
# 框架核心
## 1，适配器(Adaptor)
目前框架的屏幕适配方案为，背景使用widegt组件，拉伸背景铺满屏幕，显示节点按自己项目的固定分辨率居中于屏幕，当屏幕大小发生变化时，动态适配，
- 当屏幕的分辨率等于设计的分辨率时，正常适配
- 当屏幕的分辨率小于设计的分辨率时，会出现上下黑边
- 当屏幕的分辨率大于设计的分辨率但不超过最大限制时，会拉伸背景铺满屏幕，显示节点按项目的设计分辨率剧中显示
- 当屏幕的分辨率大于设计的分辨率但超过了最大的限制，以最大支持的分辨率进行适配
## 2，资源管理模块
### 资源管理器(AssetManager)
**该模块请勿直接调用，相关的资源管理必须通过对扩展的组件loadXX接口来调用，以保证资源正常交给资源管理器模块。如果需要扩展自己的接口，请参考框架中的其它load接口的写法扩展，保证资源的有效管理。**
- 远程资源加载，目前只扩展了对远程图片加载，及远程sp.SkeletonData的加载，加载后的资源会自动的添加到【资源缓存管理器】中。如果远程加载图片
```ts
cc.Sprite.prototype.loadRemoteImage = function (config) {
    let me = this;
    if (config.isNeedCache == undefined || config.isNeedCache == null) {
        config.isNeedCache = true;
    }
    let isRetain = false;
    if (config.retain) {
        isRetain = true;
    }
    let defaultBundle = getBundle({bundle:config.defaultBundle,view:config.view})
    Manager.assetManager.remote.loadImage(config.url, config.isNeedCache).then((data) => {
        if (data) {
            setSpriteSpriteFrame(config.view, config.url, me, data, config.completeCallback,Macro.BUNDLE_REMOTE, Resource.Type.Remote, isRetain);
        } else {
            if (config.defaultSpriteFrame) {
                if (typeof config.defaultSpriteFrame == "string") {
                    //动态加载了一张图片，把资源通知管理器
                    Manager.cacheManager.getCacheByAsync(config.defaultSpriteFrame,cc.SpriteFrame,defaultBundle).then((spriteFrame) => {
                        setSpriteSpriteFrame(config.view, config.defaultSpriteFrame, me, spriteFrame, config.completeCallback,defaultBundle);
                    });
                }
            }
            if (config.completeCallback && cc.isValid(me)) config.completeCallback(data);
        }
    });
};
```
- 本地资源加载，只能加载resources 及各bundle中的资源，加载完成后的资源也会自动的缓存到【资源缓存管理器】中。如在UIManager中的调用示例
```ts
private loadPrefab( bundle: BUNDLE_TYPE, url: string, progressCallback: (completedCount: number, totalCount: number, item: any) => void) {
        return new Promise<cc.Prefab>((resolove, reject) => {
            if ( bundle == undefined || bundle == "" || bundle == null ){
                bundle = Macro.BUNDLE_RESOURCES;
            }
            Manager.assetManager.load(bundle,url,cc.Prefab,progressCallback,(data) => {
                if (data && data.data && data.data instanceof cc.Prefab) {
                    resolove(data.data);
                }
                else {
                    reject(`加载prefab : ${url} 失败`)
                }
            });
        });
    }
```
### Bundle管理器(BundleManager)
- 对Bundle的加载及热更新检查的相关操作,进入Bundle
```ts
//进入bundle
Manager.bundleManager.enterBundle(new HotUpdate.BundleConfig("大厅", Config.BUNDLE_HALL, 0, Logic.Event.ENTER_HALL, true));
//删除已经加载的Bundle
Manager.bundleManager.removeLoadedBundle();
//删除所有子游戏bundle,大厅除外
Manager.bundleManager.removeLoadedGamesBundle();
```
### 资源缓存管理器(CacheManager)
- 资源管理器加载过的所有资源都会缓存在该管理器中
- 下面介绍下几个常用接口功能及用法
- 1,同步获取资源缓存接口，非Promise,**该接口请勿直接使用,只有在资源已经加载完成时，才能正常的使用该接口**
```ts
Manager.cacheManager.get("bundlename","respath",false);
```
- 2,获取资源缓存接口,Promise对象，**如果资源正在加载中，会等待资源加载完成后返回
否则直接返回null**
```ts
Manager.cacheManager.getCache("urlPath",cc.AudioClip,"hall").then((data)=>{
    //to do ...
});
```
- 3,获取资源缓存接口,Promise对象,**获取资源时，如果本地找不到该资源，会动态去尝试加载该资源，并返回**
```ts
Manager.cacheManager.getCacheByAsync("urlPath",cc.AudioClip,"hall").then((data)=>{
    //to do ...
});
```
### 资源加载器(ResourceLoader)
- 提供了一个资源加载器，主要用于再进入模块Logic中，加载该模块需要的资源，如果再进入某个bundle时，
需要提前加载某些特定的资源，及预加载当前bundle的GameView时，可在进入bundle时，使用bnundle的Logic
入口this._loader.loadResources()来通知加载器加载资源,非该模块的东西，先不用关心，后面Logic会说到
这里只讲解如何使用ResourceLoader，以下是一个固定的模板,主要步骤如下
- 1，监听进入bundle事件
- 2，监听进入bundle完成事件
- 3，监听资源加载完成事件
- 4，监听资源加载中事件
- 5，返回需要加载资源及预加载的界面
```ts
/**
 * @description 坦克大战Logic 
 */
class TankBattleLogic extends LogicImpl {

    logicType: Logic.Type = Logic.Type.GAME;

    language = new TankBattleLanguage;
    onLoad() {
        super.onLoad();
    }

    protected addEvents() {
        super.addEvents();
        /**@description 1，监听进入bundle事件 */
        this.addUIEvent(Logic.Event.ENTER_GAME, this.onEnterGame);
    }

    protected get bundle() {
        return TankBettle.gameData.bundle;
    }

    /**@description 2，监听进入bundle完成事件 */
    public onEnterComplete(data: Logic.EventData) {
        super.onEnterComplete(data);
        if (data.type == this.logicType) {

        } else {
            //卸载资源
            this._loader.unLoadResources();
        }
    }

    /**@description 3，监听资源加载完成事件 */
    protected onLoadResourceComplete(err: Resource.LoaderError) {
        if (err == Resource.LoaderError.LOADING) {
            return;
        }
        cc.log(`${this.bundle}资源加载完成!!!`);
        super.onLoadResourceComplete(err);
        //to do 打开自己的GameView
        Manager.uiManager.open({ type: TankBattleGameView, bundle: this.bundle });
    }

    /**@description 4，监听资源加载中事件 */
    protected onLoadResourceProgress( loadedCount : number , total : number , data : Resource.CacheData ){
        //to do 显示加载进度
    }

    private onEnterGame(data) {
        if (data == this.bundle) {
            //to do
            //加载资源
            this._loader.loadResources();
        } else {
            //to do
            //卸载资源
            this._loader.unLoadResources();
        }
    }

    /**@description 5，返回需要加载资源及预加载的界面 */
    protected getLoadResources(): Resource.Data[] {
        return [{ preloadView: TankBattleGameView, bundle: this.bundle }];
    }
}
```

## 事件模块
- 该模块为提供一个通用型事件广播，添加事件的类型任意，不受控件的限制，不管控制是否存在激活状态
都能正常的收发广播事件
- 1，向事件派发器添加广播事件
```ts
export default class Alert {
    constructor() {
        Manager.eventDispatcher.addEventListener(Macro.ADAPT_SCREEN, this.onAdaptScreen, this);
    }
    private onAdaptScreen() {
        Manager.adaptor.fullScreenAdapt(this.curPanel);
    }
}
```
- 2，派发广播事件,**对全局设置了dispatch,可直接使用全局的**
```ts
dispatch(Logic.Event.ENTER_HALL)
//等价于,建议使用dispatch
Manager.eventDispatcher.dispatchEvent(Logic.Event.ENTER_HALL, data);
```
## 热更新
- 本框架采用差量更新方法，还未支持zip压缩包的更新，热更新地址可支持动态更换，以防止热更新服务出现异常
造成玩家无法热更新情况，**该模块目前未完善，需要使用框架者自行根据自己的需要定制，框架只实现了最基础
的更新逻辑流程**
常用方法：
- 1,设置热更新地址
```ts
this.hotupdate.commonHotUpdateUrl = Config.TEST_HOT_UPDATE_URL_ROOT;
```
- 2,是否跳过热更新检查
```ts
this.hotupdate.isSkipCheckUpdate = Config.isSkipCheckUpdate;
```
- 3,可单独设置每一个bundle的热更新地址，**如果有需要每一个bundle(即子游戏都有不同的热更新地址，可自行设置)**
```ts
this.hotupdate._hotUpdateUrls = {"hall":"http://hall","test":"http://test"}
```
- 4,主包检查更新,示例代码如下:
```ts
Manager.hotupdate.checkHallUpdate((code, state) => {
    //to do ...
});
```
- 5，Bundle检测更新,即子游戏
```ts
Manager.hotupdate.checkGameUpdate(this.curBundle.bundle, (code, state) => {
    //to do ...  
});
```
## 多国语言
- **该模块未完善，后续会更新的支持多语言切换，包含资源的切换，目前只支持对文字进行切换**
- 1,添加语言包数据代理
- 2,移除语言包数据代理
```ts
/**
 * @description 坦克大战Logic 
 */
class TankBattleLogic extends LogicImpl {

    logicType: Logic.Type = Logic.Type.GAME;

    language = new TankBattleLanguage;
    onLoad() {
        super.onLoad();
    }

    protected addEvents() {
        super.addEvents();
        /**@description 1，监听进入bundle事件 */
        this.addUIEvent(Logic.Event.ENTER_GAME, this.onEnterGame);
    }

    protected get bundle() {
        return TankBettle.gameData.bundle;
    }

    /**@description 2，监听进入bundle完成事件 */
    public onEnterComplete(data: Logic.EventData) {
        super.onEnterComplete(data);
        if (data.type == this.logicType) {

        } else {
            //2,移除语言包数据代理
            Manager.language.removeSourceDelegate(this.language);
        }
    }

    private onEnterGame(data) {
        if (data == this.bundle) {
            //to do
            //1,添加语言包数据代理
            Manager.language.addSourceDelegate(this.language);
        } else {
            //to do
            //卸载资源
            this._loader.unLoadResources();
        }
    }
}
```
- 3,切换语言包代码数据源
```ts
/**@description 语言包具体的代码实现 */
import { i18n } from "../../../../scripts/common/language/CommonLanguage";
import { TankBettle } from "./TankBattleGameData";
import { TANK_LAN_EN } from "./TankBattleLanguageEN";
import { TANK_LAN_ZH } from "./TankBattleLanguageZH";
export class TankBattleLanguage implements Language.DataSourceDelegate{
    name = TankBettle.gameData.bundle;
    data( language : string ): Language.Data {

        let data : any = i18n;
        if( data[`${this.name}`] && data[`${this.name}`].language == language ){
            return i18n;
        }
        let lan = TANK_LAN_ZH;
        if (language == TANK_LAN_EN.language) {
            lan = TANK_LAN_EN;
        }
        data[`${this.name}`] = {};
        data[`${this.name}`] = lan.data;
        data[`${this.name}`].language = lan.language;
        return i18n;
    }
}
```
- 4,获取语言包文字
```ts
//生成多语言设置，对Label组件的language 进行赋值，当收到语言变量时，Label会根据当前的语言设置重新刷新显示语言
Manager.makeLanguage("Instructions", this.bundle)
//获取语言文字，只能对Label组件的string进行赋值，语言包发生变化时，Label不会根据当前的语言设置刷新
Manager.getLanguage(["warningReconnect", service.serviceName]);
```
- 5,获取当前语言类型
```ts
Manager.language.getLanguage()
```
## 日志
本框架重定向了日志，在开发过程中，请务必使用cc.log/cc.warn/cc.error/cc.dump等函数来输出日志方便后续对日志的统计及定制化的模块的日志屏蔽，

## 逻辑处理模块
- 逻辑实现模块，即bundle入口的统一实现基类，该模块处理了对bundle（即子游戏）的资源加载与卸载，bundle
网络控制器的添加与删除，多语言包数据代码的添加与移除（持续优化中）
- 以下是一个完成的Logic示例代码
- 1，指定logic类型
- 2，监听logic进入事件
- 3，监听logic进入完成事件
- 4，返回当前bundle名
- 5，返回该模块网络控制器数据
- 6，监听资源加载与卸载相关事件
- 7，返回需要加载资源的配置信息
- 8，添加logic到logic管理器中
```ts
/**
 * @description 坦克大战Logic
 */
class TankBattleLogic extends LogicImpl {

    logicType: Logic.Type = Logic.Type.GAME;

    language = new TankBattleLanguage;
    onLoad() {
        super.onLoad();
    }

    protected addEvents() {
        super.addEvents();
        this.addUIEvent(Logic.Event.ENTER_GAME, this.onEnterGame);
        this.addUIEvent(Logic.Event.ENTER_ROOM_LIST, this.onEnterRoomList);
    }

    protected get bundle() {
        return TankBettle.gameData.bundle;
    }

    public onEnterComplete(data: Logic.EventData) {
        super.onEnterComplete(data);
        if (data.type == this.logicType) {

        } else {
            //删除子包的语言包
            Manager.language.removeSourceDelegate(this.language);
            //移除网络组件
            this.removeNetComponent();
            //卸载资源
            this._loader.unLoadResources();
        }
    }

    private onEnterRoomList(data) {
        //打开自己的子游戏房间列表
    }

    protected onLoadResourceComplete(err: Resource.LoaderError) {
        if (err == Resource.LoaderError.LOADING) {
            return;
        }
        cc.log(`${this.bundle}资源加载完成!!!`);
        super.onLoadResourceComplete(err);
        //加载完成，恢复网络
        LobbyService.instance.resumeMessageQueue();
        //资源加载完成，打开bundle的GameView,即场景视图
        Manager.uiManager.open({ type: TankBattleGameView, bundle: this.bundle });
    }

    protected getNetControllerType() {
        //返回网络控制器类型
        return TankBattleNetController
    }

    private onEnterGame(data) {
        if (data == this.bundle) {

            //游戏数据初始化
            Manager.gameData = TankBettle.gameData;
            Manager.gameData.clear();

            //子游戏语言包初始化
            Manager.language.addSourceDelegate(this.language);

            //添加网络组件
            this.addNetComponent();

            //先暂停网络回调处理，等待资源加载完成后，恢复处理
            LobbyService.instance.pauseMessageQueue();
            //加载资源
            this._loader.loadResources();
        } else {

            //移除网络组件
            this.removeNetComponent();
            //卸载资源
            this._loader.unLoadResources();
        }
    }

    protected getLoadResources(): Resource.Data[] {
        //返回当前需要提前加载的资源
        return [{ preloadView: TankBattleGameView, bundle: this.bundle }];
    }
}
//向logic管理器中添加bundle的logic
Manager.logicManager.push(TankBattleLogic);
```
## 网络模块
### http 模块
- 该模块以短链接形式请求网络数据，把需要的数据以打包形式进行发送，自由性高，扩展性高,如下代码示例:
```ts
    sendHttpMessage() {

        let httpPackage = new HttpPackage();
        httpPackage.data.url = "https://httpbin.org/post";
        httpPackage.data.type = Http.Type.POST;
        //"text/plain;charset=UTF-8""Accept-Encoding","gzip,deflate"
        //httpPackage.data.requestHeader = [{name : "Content-Type" , value : "text/plain"},{name:"Accept-Encoding",value:"gzip,deflate"}]
        httpPackage.data.requestHeader = { name: "Content-Type", value: "text/plain" }
        httpPackage.data.data = new Uint8Array([1, 2, 3, 4, 5]);
        httpPackage.send((data) => {
            cc.log("数据返回")
        }, () => {
            cc.log("数据错误")
        })

        httpPackage = new HttpPackage();
        httpPackage.data.url = "https://httpbin.org/get";
        // httpPackage.data.requestHeader = {name : "Content-Type" , value : "text/plain"}
        httpPackage.params = {
            a: 100,
            b: "zheng"
        }
        httpPackage.send((data) => {
            cc.log("数据返回")
        }, () => {
            cc.log("数据错误")
        })
    }
```
### message模块
- 该模块下主要对主流数据类型的一个封装，自己项目可自行裁剪，目前支持的数据类型有**Json|Protobuffer|BinaryStream，目前框架发送的数据都会转换成二进制流，非明文方法传输，提高数据的安全性，在开发
阶段，可使自己提示toString接口来方便对数据结构的输出**
### 网络服务模块
- 网络请求模块(NetHelper)**该模块只是提示一个统一的请求接口，当你需要把游戏每成模块化进行管理，
可继承实现达到模块化，在外部直接使用，建议把请求细分的模块放到Mananger上，以免到处的引入**
- 参考示例：
```ts
//Vip模块
class VipHelper extends NetHelper<GameService>{

    constructor() {
        super(GameService.instance);
    }
    sendVipInfo(hello: string) {
        let request = new VipInfoRequest();
        this.service.send(request);
    }
}
//聊天模块
class ChatHelper extends NetHelper<GameService>{

    constructor() {
        super(GameService.instance);
    }
    sendChat(hello: string) {
        let request = new ChatRequest();
        this.service.send(request);
    }
}

//添加到Manager中
/**@description 游戏所有运行单例的管理 */
class _Manager extends Framewok implements GameEventInterface {
    //...
    private _vipHelper: VipHelper = null;
    get vipHelper(){ 
        if ( this._vipHelper ){
            return this._vipHelper;
        }
        this._vipHelper = new VipHelper();
        return this._vipHelper;
    }

    private _chatHelper: ChatHelper = null;
    get vipHelper(){ 
        if ( this._chatHelper ){
            return this._chatHelper;
        }
        this._chatHelper = new VipHelper();
        return this._chatHelper;
    }
}
```