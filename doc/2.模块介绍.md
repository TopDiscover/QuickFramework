# 公共组件
## 1，声音组件AudioComponent
集成了对声音的播放，停止，音量大小调整等功能
该声音组件会在UIView的onLoad中初始化，每一个UIView都具有播放声音的组件
- 背景音乐,如果是在onLoad中播放，必须先调用基类的onLoad后再使用this.audioHelper，
目前只支持一个背景音乐的播放，当playMusic下一个音乐时，会自动停止掉之前的背景音乐，播放当前背景音乐
如某些资源希望播放后，一直驻留在内存中，可使用Manager.globalAudio来对声音进行操作，该声音全局组件
播放的资源，都会默认为全局常驻资源，生命周期跟App的生命周期一致
```ts
//播放背景音乐，
this.audioHelper.playMusic("audio/background",this.bundle);
//停止背景音乐
this.audioHelper.stopMusic()
//播放全局背景音乐，前提，该背景音效文件在主包内，否则可能会出现退出bundle删除bundle资源，造成第二次无法正常播放
//可直接使用全局声音组件，这种情况下播放的音乐，将会一直驻留在内存中，直接游戏退出才会释放
Manager.globalAudio.playMusic("audio/background",this.bundle);
//使用全局播放，使用全局的停止
Manager.globalAudio.stopMusic()
```
- 音效，音效的返回是一个异步处理的过程，如果没有加载音效情况下，调用播放接口会先加载完成才会播放，在Promise回调中返回音效id
```ts
//播放音效
this.audioHelper.playEffect("audiourl",this.bundle,false).then((id)=>{
    this.audioID = id;
});
//停止音效
this.audioHelper.stopEffect(this.audioID);
//如弹出框的公共声音，可直接使用全局的声音组件操作Manager.globalAudio
```
- 音量
音量的设置是对全局进行设置，全局的声音组件及UIView的声音组件都能操作当前游戏的音量设置
```ts
//音效音量
this.audioHelper.effectVolume = value; //value(0.0~1.0)
//背景音乐音量
this.audioHelper.musicVolume = value; //value(0.0~1.0)
```
- 声音开关
声音开关的设置，同音量一样，全局的声音组件及UIView的声音组件都能操作当前游戏的音量开关设置
```ts
//音效开关
this.audioHelper.isEffectOn = true;
//背景音效开关
this.audioHelper.isMusicOn = true;
```
- 声音用户数据保存,全局的声音组件及UIView的声音组件都能操作当前游戏的用户数据保存
```ts
this.audioHelper.save()
```
## 2，网络控制器Controller
个人建议，该模块只用于对网络数据的接收逻辑业务的处理，如果当你收到某个网络消息后，处理完相关数据流程在通知视图更新显示，
- service注入，该组件接收来自哪一条网络的
- 网络事件注册绑定
- 网络控制器注册到网络管理器中
示例如下:
```ts
//网络注入
@setService(ChatService.instance)
export default class TestChatNetController extends Controller<ChatService> {
    //绑定网络事件
    protected addEvents() {
        super.addEvents()
        this.addNetEvent(GetCmdKey(MainCmd.CMD_LOBBY, SUB_CMD_LOBBY.TEST_JSON_MSG), this.onTestJsonMessage, TestJsonMessage, true);
    }
    //网络事件处理
    private onTestJsonMessage(data: TestJsonMessage) {
        //对网络数据进入处理之后，得到界面需要结果
        if ( Manager.gameView) Manager.gameView.updateView(data);
        //如需要其它地方收到此消息的数据，可派发广播，如果玩家金钱变更等，根据自己的业务逻辑而定
        dispatch(CommonEvent.TEST_JSON_MSG, data.hello);
    }
}

Manager.hallNetManager.register(TestChatNetController);
```
## 3，事件组件EventComponent
该组件主要用于对网络及UI事件的绑定，只要是EventComponent的子类，都有接收全局广播事件的能力
# 框架核心
## 1，适配器(Adaptor)
目前框架的屏幕适配方案为，背景使用widegt组件，拉伸背景铺满屏幕，显示节点按自己项目的固定分辨率居中于屏幕，当屏幕大小发生变化时，动态适配，
- 当屏幕的分辨率等于设计的分辨率时，正常适配
- 当屏幕的分辨率小于设计的分辨率时，会出现上下黑边
- 当屏幕的分辨率大于设计的分辨率但不超过最大限制时，会拉伸背景铺满屏幕，显示节点按项目的设计分辨率剧中显示
- 当屏幕的分辨率大于设计的分辨率但超过了最大的限制，以最大支持的分辨率进行适配
## 2，资源管理模块
### 资源管理器(AssetManager)
**该模块请勿直接调用，相关的资源管理必须通过对扩展的组件loadXX接口来调用，以保证资源正常交给资源管理器模块。如果需要扩展自己的接口，请参考框架中的其它load接口的写法扩展，保证资源的有效管理。**
- 远程资源加载，目前只扩展了对远程图片加载，及远程sp.SkeletonData的加载，加载后的资源会自动的添加到【资源缓存管理器】中。如果远程加载图片
```ts
cc.Sprite.prototype.loadRemoteImage = function (config) {
    let me = this;
    if (config.isNeedCache == undefined || config.isNeedCache == null) {
        config.isNeedCache = true;
    }
    let isRetain = false;
    if (config.retain) {
        isRetain = true;
    }
    let defaultBundle = getBundle({bundle:config.defaultBundle,view:config.view})
    Manager.assetManager.remote.loadImage(config.url, config.isNeedCache).then((data) => {
        if (data) {
            setSpriteSpriteFrame(config.view, config.url, me, data, config.completeCallback,Macro.BUNDLE_REMOTE, Resource.Type.Remote, isRetain);
        } else {
            if (config.defaultSpriteFrame) {
                if (typeof config.defaultSpriteFrame == "string") {
                    //动态加载了一张图片，把资源通知管理器
                    Manager.cacheManager.getCacheByAsync(config.defaultSpriteFrame,cc.SpriteFrame,defaultBundle).then((spriteFrame) => {
                        setSpriteSpriteFrame(config.view, config.defaultSpriteFrame, me, spriteFrame, config.completeCallback,defaultBundle);
                    });
                }
            }
            if (config.completeCallback && cc.isValid(me)) config.completeCallback(data);
        }
    });
};
```
- 本地资源加载，只能加载resources 及各bundle中的资源，加载完成后的资源也会自动的缓存到【资源缓存管理器】中。如在UIManager中的调用示例
```ts
private loadPrefab( bundle: BUNDLE_TYPE, url: string, progressCallback: (completedCount: number, totalCount: number, item: any) => void) {
        return new Promise<cc.Prefab>((resolove, reject) => {
            if ( bundle == undefined || bundle == "" || bundle == null ){
                bundle = Macro.BUNDLE_RESOURCES;
            }
            Manager.assetManager.load(bundle,url,cc.Prefab,progressCallback,(data) => {
                if (data && data.data && data.data instanceof cc.Prefab) {
                    resolove(data.data);
                }
                else {
                    reject(`加载prefab : ${url} 失败`)
                }
            });
        });
    }
```
### Bundle管理器(BundleManager)
- 对Bundle的加载及热更新检查的相关操作,进入Bundle
```ts
//进入bundle
Manager.bundleManager.enterBundle(new HotUpdate.BundleConfig("大厅", Config.BUNDLE_HALL, 0, Logic.Event.ENTER_HALL, true));
//删除已经加载的Bundle
Manager.bundleManager.removeLoadedBundle();
//删除所有子游戏bundle,大厅除外
Manager.bundleManager.removeLoadedGamesBundle();
```
### 资源缓存管理器(CacheManager)
- 资源管理器加载过的所有资源都会缓存在该管理器中
- 下面介绍下几个常用接口功能及用法
- 1,同步获取资源缓存接口，非Promise,**该接口请勿直接使用,只有在资源已经加载完成时，才能正常的使用该接口**
```ts
Manager.cacheManager.get("bundlename","respath",false);
```
- 2,获取资源缓存接口,Promise对象，**如果资源正在加载中，会等待资源加载完成后返回
否则直接返回null**
```ts
Manager.cacheManager.getCache("urlPath",cc.AudioClip,"hall").then((data)=>{
    //to do ...
});
```
- 3,获取资源缓存接口,Promise对象,**获取资源时，如果本地找不到该资源，会动态去尝试加载该资源，并返回**
```ts
Manager.cacheManager.getCacheByAsync("urlPath",cc.AudioClip,"hall").then((data)=>{
    //to do ...
});
```
### 资源加载器(ResourceLoader)
- 提供了一个资源加载器，主要用于再进入模块Logic中，加载该模块需要的资源，如果再进入某个bundle时，
需要提前加载某些特定的资源，及预加载当前bundle的GameView时，可在进入bundle时，使用bnundle的Logic
入口this._loader.loadResources()来通知加载器加载资源,非该模块的东西，先不用关心，后面Logic会说到
这里只讲解如何使用ResourceLoader，以下是一个固定的模板,主要步骤如下
- 1，监听进入bundle事件
- 2，监听进入bundle完成事件
- 3，监听资源加载完成事件
- 4，监听资源加载中事件
- 5，返回需要加载资源及预加载的界面
```ts
/**
 * @description 坦克大战Logic 
 */
class TankBattleLogic extends LogicImpl {

    logicType: Logic.Type = Logic.Type.GAME;

    language = new TankBattleLanguage;
    onLoad() {
        super.onLoad();
    }

    protected addEvents() {
        super.addEvents();
        /**@description 1，监听进入bundle事件 */
        this.addUIEvent(Logic.Event.ENTER_GAME, this.onEnterGame);
    }

    protected get bundle() {
        return TankBettle.gameData.bundle;
    }

    /**@description 2，监听进入bundle完成事件 */
    public onEnterComplete(data: Logic.EventData) {
        super.onEnterComplete(data);
        if (data.type == this.logicType) {

        } else {
            //卸载资源
            this._loader.unLoadResources();
        }
    }

    /**@description 3，监听资源加载完成事件 */
    protected onLoadResourceComplete(err: Resource.LoaderError) {
        if (err == Resource.LoaderError.LOADING) {
            return;
        }
        cc.log(`${this.bundle}资源加载完成!!!`);
        super.onLoadResourceComplete(err);
        //to do 打开自己的GameView
        Manager.uiManager.open({ type: TankBattleGameView, bundle: this.bundle });
    }

    /**@description 4，监听资源加载中事件 */
    protected onLoadResourceProgress( loadedCount : number , total : number , data : Resource.CacheData ){
        //to do 显示加载进度
    }

    private onEnterGame(data) {
        if (data == this.bundle) {
            //to do
            //加载资源
            this._loader.loadResources();
        } else {
            //to do
            //卸载资源
            this._loader.unLoadResources();
        }
    }

    /**@description 5，返回需要加载资源及预加载的界面 */
    protected getLoadResources(): Resource.Data[] {
        return [{ preloadView: TankBattleGameView, bundle: this.bundle }];
    }
}
```

## 事件模块
- 该模块为提供一个通用型事件广播，添加事件的类型任意，不受控件的限制，不管控制是否存在激活状态
都能正常的收发广播事件
- 1，向事件派发器添加广播事件
```ts
export default class Alert {
    constructor() {
        Manager.eventDispatcher.addEventListener(Macro.ADAPT_SCREEN, this.onAdaptScreen, this);
    }
    private onAdaptScreen() {
        Manager.adaptor.fullScreenAdapt(this.curPanel);
    }
}
```
- 2，派发广播事件,**对全局设置了dispatch,可直接使用全局的**
```ts
dispatch(Logic.Event.ENTER_HALL)
//等价于,建议使用dispatch
Manager.eventDispatcher.dispatchEvent(Logic.Event.ENTER_HALL, data);
```
## 热更新
- 本框架采用差量更新方法，还未支持zip压缩包的更新，热更新地址可支持动态更换，以防止热更新服务出现异常
造成玩家无法热更新情况，
常用方法：
- 1,设置热更新地址
```ts
this.hotupdate.commonHotUpdateUrl = Config.TEST_HOT_UPDATE_URL_ROOT;
```
- 2,是否跳过热更新检查
```ts
this.hotupdate.isSkipCheckUpdate = Config.isSkipCheckUpdate;
```
- 3,可单独设置每一个bundle的热更新地址，**如果有需要每一个bundle(即子游戏都有不同的热更新地址，可自行设置)**
```ts
this.hotupdate._hotUpdateUrls = {"hall":"http://hall","test":"http://test"}
```
- 4,主包检查更新,示例代码如下:
```ts
Manager.hotupdate.checkHallUpdate((code, state) => {
    //to do ...
});
```
- 5，Bundle检测更新,即子游戏
```ts
Manager.hotupdate.checkGameUpdate(this.curBundle.bundle, (code, state) => {
    //to do ...  
});
```
