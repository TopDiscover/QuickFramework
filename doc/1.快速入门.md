# 关于QuickFramework
- **Q : 为什么使用单场景？**
    - **保证视图在切换场景时正常弹出**
    * 如下情况，如多场景情况下，A场景->B场景，A场景上请求网络数据希望在B场景上弹出，当收到网络返回时
    还需要检查当前是否在B场景中，如果不在则压入到显示队列中，等进入B场景，检查当前是否有显示视图队列
    如果有显示的视图，依次弹出，但如果采用单场景化，无须关心在哪一个场景，收到网络回复直接弹出。
    - **保护界面状态**
    * 还是在多场景下，在切换场景时，必定会先把场景上所有视图关闭，清除数据，但若有需要在A场景下显示的
    界面也希望在B场景下显示，此时场景的过渡，会先关闭界面，进入B场景时显示，但如果场景上有ListView类
    似的控件，也希望在切换场景时，显示之前玩家操作显示的位置，那么必定会花费额外的工作去保存玩家在A场景
    上操作界面的相关信息，再进入B场景时，恢复玩家对界面操作的所有状态，但如果只是单场景，可以模拟一个
    场景的切换动作，直接隐藏掉界面，进入B场景，直接显示，无须保存界面的状态。

- **Q : 项目为什么不推荐使用在预置体中直接挂载脚本？**
    - **方便重构**
    * 如下情况，当你发现目录结构不合理，或者文件名取名有误时，但此时已经在预置上挂载了过多的组件，还有
    些项目的子游戏是在不同的svn版本管理下，在开发时，并不会放入全量的代码进入开发，如果如果此时改名或
    移动目录，可能会造成文件的uuid发生变化，Creator上只会显示该脚本为Misson状态，并不会显示之前挂载
    的是哪一个脚本，若项目足够大，一个脚本的uuid变化，可能会造成大量预置体重新设置挂载脚本，提高了
    维护的成本
- **Q : 为什么项目都采用预置体+UIView组件绑定方式？**
    - 1，统一化管理，工厂式创建，方便实现统一的动画效果，一个公司的界面显示动画，可能大多数情况下是统一风格，如果我们要实现统一定制化
    动画，只需要在UIView中统一处理，直接显示通过UIManager.open()方式调用
    * 2，把内存及资源的管理交到管理器处理，减少开发者对何时释放资源，何时加载资源的烦恼，只关注自己的
    业务逻辑处理，无须关注资源的加载与释放
    * 3，接口统一，方便后期对界面的打开次数统计，以提供数据给运营人员，查看该模块的受欢迎程度
- **Q : 项目主要核心模块为什么都在管理器Manager上？**
    - 提高可读性，新手上手快，拿到代码只能从Manager上直接了解整个项目的结构模块，尽量避免全局变量满天飞的情况
    后面框架的使用者也可直接把全局的通过数据直接挂载到Manager中使用，减少全局变量的污染。
- **Q : 项目为什么推荐万事尽量保留类型？***
    - 个人观点，项目采用VSCode + Creator + typescript 方式进行开发，而typescript VSCode 都是Microsoft 公司
    的产品，Microsoft公司在JavaScript 基础上加上了type,就是为了解决弱语言类型无类型化，可读性差，
    * 1，您可以清楚你的实际来自哪一个类型，跟继承的关系
    * 2，编辑友好加上VSCode的智能代码提示跟静态语法检查，让你在开发时，减少错误
    * 3，代码更严谨，可在传入参数中限制传入的类型，类型的检查交给VSCode处理
    * 4，方便重构，如果当你发现某个文件放置位置不对，可直接在VSCode中拖动到你想要的位置，VSCode会自动的更正你托动
    代码所有引用的位置，或者对API 类名等修改操作，VSCode也会自动更改所有引用此类型的地方，降低重构的成本
    * 5，最后说一句，没有人比VSCode 更懂TypeScript ,TypeScript的重点在Type,无论什么情况，尽量保留类型。
# 框架定位
本框架主要为轻量级游戏打造的一个基础框架雏形，可适用于休闲类，小游戏类，棋牌类，文字游戏类等轻或中度型游戏的开发，
功能还在完善中，后面优化及功能的扩展继续进行中
# 如何使用框架
## 1，修正你的Creator引擎
本框架提供了相应的插件，对引擎有部分源码的修改，再下载完本项目，用Creator打后开需要先执行引擎修正，以确保对引擎修改的部分同步到您的Creator安装目录

![引擎修正](https://images.gitee.com/uploads/images/2021/0904/223205_803c6978_393413.png "屏幕截图.png")
## 2，创建目录结构
可参考如下结构

![结构说明](https://images.gitee.com/uploads/images/2021/0904/224514_d546e3cc_393413.png "屏幕截图.png")

- animation 为动画资源
- audio 声音资源
- font 字体资源
- image 为散图不会打包成大图集资源
- prefabs 为预置体存放位置
- script 为bundle的代码存放位置
- texture 为打包自动图集资源

**可根据自己项目及个人习惯而定**

## 3，设置Bundle

如下图

![设置Bundle](https://images.gitee.com/uploads/images/2021/0904/225100_40e33148_393413.png "屏幕截图.png")

## 4，编写bundle逻辑入口
- **1,入口继承Entry**
- **2,使用装饰器注册bundle入口程序**
```ts
@registerEntry("SnapshotEntry","snapshot",SnapshotView)
class SnapshotEntry extends Entry{
    protected addNetHandler(): void {
        
    }
    protected removeNetHandler(): void {
        
    }
    protected loadResources(completeCb: () => void): void {
        completeCb();
    }
    protected initData(): void {
        
    }
    protected pauseMessageQueue(): void {
        
    }
    protected resumeMessageQueue(): void {
        
    }
}
```
## 5，创建SnapshotView预置

## 6，创建SnapshotView视图脚本
- **1，继承UIView实现视图**
- **2，绑定脚本与预置体关系**
- **3，退出当前bundle，进入大厅**
- **代码如下：**

```ts
const {ccclass, property} = cc._decorator;

@ccclass
export default class SnapshotView extends GameView {

    /**@description 绑定脚本与预置关系 */
    public static getPrefabUrl(){
        return "prefabs/SnapshotView";
    }

    @inject("goBack",cc.Node)
    private goback : cc.Node = null;

    onLoad(){
        super.onLoad();
        this.goback.on(cc.Node.EventType.TOUCH_END,()=>{
            // 返回到大厅
            this.enterBundle(Config.BUNDLE_HALL);
        });
    }
}
```
## 7，编写主入口逻辑
- 如本项目中的**[LoginEntry](../proj/assets/scripts/login/LoginEntry.ts)**
- 参考代码

```ts
class LoginEntry extends Entry {
    static bundle = Macro.BUNDLE_RESOURCES;
    /**@description 是否是主包入口，只能有一个主包入口 */
    isMain = true;
}
```
**到此，整个小白教程完成，如何创建自己的界面及bundle，更新详细的部分请参考[模块介绍](2.模块介绍.md)**